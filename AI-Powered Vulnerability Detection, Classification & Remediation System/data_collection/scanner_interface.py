"""
Interface for network and system vulnerability scanners.
Currently supports Nmap for network scanning.
"""

import logging
import json
import xml.etree.ElementTree as ET
from pathlib import Path
import subprocess
import nmap
import os

logger = logging.getLogger(__name__)

class NmapScanner:
    """Interface to Nmap network scanner."""
    
    def __init__(self, output_dir=None, nmap_path=None):
        """Initialize the scanner interface."""
        self.output_dir = output_dir
        if output_dir:
            os.makedirs(output_dir, exist_ok=True)
            
        # Explicitly specify the nmap path if it's not found automatically
        if not nmap_path:
            if os.path.exists('C:\\Program Files (x86)\\Nmap\\nmap.exe'):
                    nmap_path = 'C:\\Program Files (x86)\\Nmap\\nmap.exe'
            elif os.path.exists('C:\\Program Files\\Nmap\\nmap.exe'):
                nmap_path = 'C:\\Program Files\\Nmap\\nmap.exe'
            
        self.nm = nmap.PortScanner(nmap_search_path=(nmap_path,) if nmap_path else ())
    
    def scan(self, targets, scan_type='basic', output_file=None):
        """
        Perform an Nmap scan.
        
        Args:
            targets: Target IP addresses or hostnames (string or list)
            scan_type: Type of scan to perform ('basic', 'full', 'vuln', 'os')
            output_file: Filename for scan results
            
        Returns:
            Dictionary containing scan results
        """
        if isinstance(targets, list):
            targets = ' '.join(targets)
        
        scan_args = self._get_scan_args(scan_type)
        
        if not output_file:
            scan_name = scan_type.replace(' ', '_')
            # Fix: Ensure the output_dir is used properly when constructing the output_path
            if self.output_dir:
                output_path = Path(self.output_dir) / f"nmap_scan_{scan_name}_{targets.replace(' ', '_')}.xml"
            else:
                output_path = Path(f"nmap_scan_{scan_name}_{targets.replace(' ', '_')}.xml")
        else:
            # Fix: Ensure output_file is handled properly with output_dir
            if self.output_dir:
                output_path = Path(self.output_dir) / output_file
            else:
                output_path = Path(output_file)
        
        # Remove output file argument from scan_args - we'll save manually after the scan
        
        logger.info(f"Starting {scan_type} Nmap scan of {targets}")
        
        try:
            self.nm.scan(hosts=targets, arguments=scan_args)
            logger.info(f"Scan completed successfully.")
            
            # Save XML output manually after the scan
            xml_output = self.nm.get_nmap_last_output()
            
            # Fix: handle bytes output by decoding or opening file in binary mode
            if isinstance(xml_output, bytes):
                # Option 1: Decode to string
                xml_output = xml_output.decode('utf-8', errors='replace')
                with open(output_path, 'w') as f:
                    f.write(xml_output)
            else:
                # Option 2: If it's already a string
                with open(output_path, 'w') as f:
                    f.write(xml_output)
                    
            logger.info(f"Results saved to {output_path}")
            
            # Also save as JSON for easier parsing
            json_path = output_path.with_suffix('.json')
            # Fix: Convert to string for JSON serialization
            with open(json_path, 'w') as f:
                if isinstance(xml_output, bytes):
                    json.dump(xml_output.decode('utf-8', errors='replace'), f)
                else:
                    json.dump(xml_output, f)
            
            return self.parse_results(self.nm)
            
        except Exception as e:
            logger.error(f"Error during Nmap scan: {e}")
            return None
    
    def _get_scan_args(self, scan_type):
        """
        Get Nmap arguments for different scan types.
        
        Args:
            scan_type: Type of scan ('basic', 'full', 'vuln', 'os')
            
        Returns:
            String with Nmap arguments
        """
        scan_types = {
            'basic': '-sV -F --script=banner',  # Fast version scan with service detection
            'full': '-sS -sV -sC -A -T4',  # SYN scan with service detection, scripts and OS detection
            'vuln': '-sV --script=vuln',  # Vulnerability scanning
            'os': '-sS -O',  # OS detection
            'service': '-sV --version-all',  # Comprehensive service detection
            'all_ports': '-p- -sV',  # Scan all 65535 ports
            'windows': '-sV -sC --script=smb-os-discovery,smb-vuln*,ms-sql*,rdp*',  # Windows-specific scanning
            'xp': '-sV -sC -O --script=smb-os-discovery,smb-vuln*,smb-security-mode,rdp-vuln-ms12-020'  # XP-specific scanning
        }
        
        return scan_types.get(scan_type, '-sV')  # Default to service scan
    
    def parse_results(self, nm_results):
        """
        Parse Nmap scan results into a structured format.
        
        Args:
            nm_results: Nmap scan results object
            
        Returns:
            Dictionary with structured scan findings
        """
        results = {
            'hosts': [],
            'total_hosts': 0,
            'up_hosts': 0,
            'down_hosts': 0,
            'scan_stats': nm_results.scanstats() if hasattr(nm_results, 'scanstats') else {}
        }
        
        # Process each host
        for host in nm_results.all_hosts():
            host_info = {
                'ip': host,
                'status': nm_results[host].state(),
                'hostnames': nm_results[host].hostnames() if hasattr(nm_results[host], 'hostnames') else [],
                'open_ports': [],
                'os': nm_results[host].get('osmatch', []) if 'osmatch' in nm_results[host] else [],
                'vulnerabilities': []
            }
            
            # Process ports and services
            if 'tcp' in nm_results[host]:
                for port, port_info in nm_results[host]['tcp'].items():
                    if port_info['state'] == 'open':
                        service_info = {
                            'port': port,
                            'service': port_info.get('name', 'unknown'),
                            'product': port_info.get('product', ''),
                            'version': port_info.get('version', ''),
                            'cpe': port_info.get('cpe', '')
                        }
                        
                        # Extract vulnerabilities from script output
                        if 'script' in port_info:
                            service_info['script_output'] = port_info['script']
                            
                            # Extract potential CVEs from script output
                            for script_name, output in port_info['script'].items():
                                if 'CVE-' in output:
                                    import re
                                    cves = re.findall(r'CVE-\d{4}-\d{4,}', output)
                                    for cve in cves:
                                        host_info['vulnerabilities'].append({
                                            'cve_id': cve,
                                            'port': port,
                                            'service': port_info.get('name', 'unknown'),
                                            'source': f"nmap:{script_name}",
                                            'description': output
                                        })
                        
                        host_info['open_ports'].append(service_info)
            
            results['hosts'].append(host_info)
        
        # Update stats
        results['total_hosts'] = len(nm_results.all_hosts())
        results['up_hosts'] = len([h for h in nm_results.all_hosts() if nm_results[h].state() == 'up'])
        results['down_hosts'] = results['total_hosts'] - results['up_hosts']
        
        return results

    def get_vulnerability_report(self, scan_results):
        """
        Extract vulnerability information from scan results.
        
        Args:
            scan_results: Results from an Nmap scan
            
        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []
        
        for host in scan_results['hosts']:
            ip = host['ip']
            
            # Add vulnerabilities already detected
            for vuln in host.get('vulnerabilities', []):
                vulnerabilities.append({
                    'host': ip,
                    'cve_id': vuln.get('cve_id', 'N/A'),
                    'port': vuln.get('port', 'N/A'),
                    'service': vuln.get('service', 'N/A'),
                    'source': vuln.get('source', 'nmap'),
                    'description': vuln.get('description', ''),
                    'severity': 'Unknown'  # Will be determined by the severity classifier
                })
            
            # Determine OS using nmap's OS detection results
            detected_os = self._determine_os(host.get('os', []))
            
            # Windows XP specific checks
            if detected_os.get('is_windows_xp', False):
                logger.info(f"Detected Windows XP with {detected_os.get('confidence')}% confidence")
                
                vulnerabilities.append({
                    'host': ip,
                    'cve_id': 'MULTIPLE',
                    'port': 'N/A',
                    'service': 'Operating System',
                    'source': 'os_detection',
                    'description': f"Unsupported OS detected: Windows XP - Vulnerable to numerous exploits including EternalBlue (MS17-010)",
                    'severity': 'Critical'
                })
                
                # Windows XP has multiple known RCE vulnerabilities
                vulnerabilities.append({
                    'host': ip,
                    'cve_id': 'CVE-2008-4250',
                    'port': '445',
                    'service': 'SMB',
                    'source': 'os_detection',
                    'description': "Windows XP vulnerable to MS08-067 (Conficker) - Remote Code Execution vulnerability",
                    'severity': 'Critical'
                })
                
                vulnerabilities.append({
                    'host': ip,
                    'cve_id': 'CVE-2017-0143',
                    'port': '445',
                    'service': 'SMB',
                    'source': 'os_detection',
                    'description': "Windows XP vulnerable to MS17-010 (EternalBlue) - Remote Code Execution vulnerability",
                    'severity': 'Critical'
                })
            
            # For other Windows versions (not XP), add informational entries
            elif detected_os.get('is_windows', False):
                windows_version = detected_os.get('os_name', 'Unknown Windows version')
                
                # Add informational vulnerability entry for the detected Windows version
                vulnerabilities.append({
                    'host': ip,
                    'cve_id': 'INFO',
                    'port': 'N/A',
                    'service': 'OS',
                    'source': 'os_detection',
                    'description': f"Detected OS: {windows_version} (Confidence: {detected_os.get('confidence')}%)",
                    'severity': 'Low'  # Just informational
                })
                
                # Check for EOL Windows versions that aren't XP but still need attention
                if self._is_eol_windows(detected_os.get('os_name', '')):
                    vulnerabilities.append({
                        'host': ip,
                        'cve_id': 'EOL-WINDOWS',
                        'port': 'N/A',
                        'service': 'OS',
                        'source': 'os_detection',
                        'description': f"End-of-Life Windows version detected: {windows_version}. No longer receiving security updates.",
                        'severity': 'Medium'
                    })
            
            # Check for potentially vulnerable services - regardless of Windows version
            for port_info in host.get('open_ports', []):
                service = port_info.get('service', '')
                product = port_info.get('product', '')
                version = port_info.get('version', '')
                port = port_info.get('port', 'N/A')
                
                # Flag potentially vulnerable services/versions
                if service == 'ssh' and version and 'OpenSSH' in product:
                    if any(v in version for v in ['5.', '6.0', '6.1', '6.2', '6.3', '6.4']):
                        vulnerabilities.append({
                            'host': ip,
                            'cve_id': 'POTENTIAL',
                            'port': port,
                            'service': f"{service} {product} {version}",
                            'source': 'version_check',
                            'description': f"Outdated {service} version detected: {product} {version}",
                            'severity': 'Medium'
                        })
                
                # RDP checks - only flag as high severity if Windows XP
                if service == 'ms-wbt-server' or port == '3389':
                    if detected_os.get('is_windows_xp', False):
                        vulnerabilities.append({
                            'host': ip,
                            'cve_id': 'CVE-2019-0708',
                            'port': port,
                            'service': 'RDP',
                            'source': 'service_check',
                            'description': "Potential BlueKeep vulnerability in RDP service on Windows XP",
                            'severity': 'High'
                        })
                
                # SMB checks - modify to avoid false positives for Windows XP
                if service in ['microsoft-ds', 'netbios-ssn', 'msrpc']:
                    # Only flag as potential Windows XP vulnerability if we haven't definitely determined the OS
                    if not detected_os.get('is_windows', False):
                        vulnerabilities.append({
                            'host': ip,
                            'cve_id': 'POTENTIAL',
                            'port': port,
                            'service': service,
                            'source': 'service_check',
                            'description': f"Windows service {service} detected - recommend OS identification scan",
                            'severity': 'Low'
                        })
                
                # Check for telnet, ftp, or other clear-text protocols
                if service in ['telnet', 'ftp']:
                    vulnerabilities.append({
                        'host': ip,
                        'cve_id': 'INSECURE_PROTOCOL',
                        'port': port,
                        'service': service,
                        'source': 'protocol_check',
                        'description': f"Insecure protocol {service} detected",
                        'severity': 'Medium'
                    })
        
        return vulnerabilities
    
    def _determine_os(self, os_matches):
        """
        Determine the operating system from nmap OS detection results.
        
        Args:
            os_matches: List of OS matches from nmap scan
            
        Returns:
            Dictionary with OS information
        """
        result = {
            'is_windows': False,
            'is_windows_xp': False,
            'os_name': 'Unknown',
            'confidence': 0
        }
        
        if not os_matches:
            return result
        
        # Get the highest confidence OS match
        best_match = None
        for os_match in os_matches:
            if isinstance(os_match, dict) and 'name' in os_match:
                confidence = float(os_match.get('accuracy', '0'))
                
                if not best_match or confidence > result['confidence']:
                    best_match = os_match
                    result['os_name'] = os_match.get('name', 'Unknown')
                    result['confidence'] = confidence
        
        if not best_match:
            return result
        
        # Check if this is a Windows system
        os_name_lower = result['os_name'].lower()
        if 'windows' in os_name_lower:
            result['is_windows'] = True
            
            # Specifically check for Windows XP
            if 'windows xp' in os_name_lower and not any(newer in os_name_lower for newer in 
                                                        ['vista', 'windows 7', 'windows 8', 
                                                         'windows 10', 'windows 11', 'server']):
                # Only mark as XP if confidence is high enough
                if result['confidence'] >= 85:
                    result['is_windows_xp'] = True
                    logger.info(f"Detected Windows XP: {result['os_name']} with {result['confidence']}% confidence")
                else:
                    logger.info(f"Possible Windows XP detected but confidence too low: {result['confidence']}%")
        
        return result
    
    def _is_eol_windows(self, os_name):
        """
        Check if the Windows version is End-of-Life.
        
        Args:
            os_name: OS name string
            
        Returns:
            Boolean indicating if the OS is EOL
        """
        os_name_lower = os_name.lower()
        
        # List of EOL Windows versions
        eol_versions = [
            'windows xp',
            'windows vista',
            'windows 7',
            'windows 8',  # Original Windows 8 (not 8.1)
            'windows server 2003',
            'windows server 2008',
            'windows server 2012'  # Will be EOL soon
        ]
        
        return any(version in os_name_lower for version in eol_versions)

    def scan_windows_xp(self, target, output_file=None):
        """
        Perform a specialized scan for Windows XP vulnerabilities.
        
        Args:
            target: Target IP address or hostname
            output_file: Optional output file name
            
        Returns:
            Dictionary with scan results and vulnerabilities
        """
        # First perform an OS detection scan
        os_results = self.scan(target, scan_type='os', output_file=output_file)
        
        # Then perform a Windows-specific vulnerability scan
        vuln_results = self.scan(target, scan_type='xp', 
                               output_file=output_file or f"xp_vuln_scan_{target.replace(' ', '_')}.xml")
        
        # Merge scan results if both were successful
        results = vuln_results if vuln_results else os_results
        
        # Get comprehensive vulnerability report
        vulnerabilities = self.get_vulnerability_report(results)
        
        return {
            'scan_results': results,
            'vulnerabilities': vulnerabilities,
            'summary': {
                'target': target,
                'total_vulnerabilities': len(vulnerabilities),
                'critical_count': sum(1 for v in vulnerabilities if v.get('severity') == 'Critical'),
                'high_count': sum(1 for v in vulnerabilities if v.get('severity') == 'High'),
                'medium_count': sum(1 for v in vulnerabilities if v.get('severity') == 'Medium'),
                'low_count': sum(1 for v in vulnerabilities if v.get('severity') == 'Low')
            }
        }

if __name__ == "__main__":
    # Example usage
    scanner = NmapScanner()
    # For Windows XP systems, use the specific scanner method
    results = scanner.scan_windows_xp('127.0.0.1')
    print(f"Found {len(results['vulnerabilities'])} potential vulnerabilities")
    print(json.dumps(results['vulnerabilities'], indent=2))
