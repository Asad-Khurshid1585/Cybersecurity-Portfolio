"""
Vulnerability severity classification module using BERT for severity prediction.
"""

import os
import logging
import torch
from transformers import AutoTokenizer, AutoModelForSequenceClassification

logger = logging.getLogger(__name__)

class VulnerabilitySeverityClassifier:
    """
    Class that predicts the severity level of vulnerabilities using a fine-tuned BERT model.
    """
    
    def __init__(self, model_dir=None):
        """
        Initialize the classifier with a BERT model.
        
        Args:
            model_dir (str): Directory containing the BERT model. If None, uses default location.
        """
        if model_dir is None:
            # Use default model location relative to project root
            model_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 
                                    'models', 'severity_bert', 'bert_model')
        
        self.model_dir = model_dir
        self.model = None
        self.tokenizer = None
        self.severity_levels = ['Low', 'Medium', 'High', 'Critical']
        
        # Load model only when needed (lazy loading)
        
    def _ensure_model_loaded(self):
        """Ensures the model is loaded before prediction."""
        if self.model is None or self.tokenizer is None:
            try:
                logger.info(f"Loading BERT model from {self.model_dir}")
                self.tokenizer = AutoTokenizer.from_pretrained(self.model_dir)
                self.model = AutoModelForSequenceClassification.from_pretrained(self.model_dir)
            except Exception as e:
                logger.error(f"Error loading BERT model: {e}")
                raise RuntimeError(f"Failed to load BERT model: {e}")
    
    def predict_single(self, description):
        """
        Predict severity for a single vulnerability description.
        
        Args:
            description (str): The vulnerability description text
            
        Returns:
            str: Predicted severity level (Low, Medium, High, Critical)
        """
        self._ensure_model_loaded()
        
        # Tokenize input
        inputs = self.tokenizer(
            description,
            padding=True,
            truncation=True,
            max_length=512,
            return_tensors="pt"
        )
        
        # Make prediction
        self.model.eval()
        with torch.no_grad():
            outputs = self.model(**inputs)
            predictions = torch.argmax(outputs.logits, dim=-1)
        
        # Map to severity level
        return self.severity_levels[predictions.item()]
    
    def predict(self, vulnerabilities):
        """
        Predict severity for multiple vulnerabilities.
        
        Args:
            vulnerabilities (list): List of vulnerability dictionaries
            
        Returns:
            list: List of predicted severity levels
        """
        results = []
        
        for vuln in vulnerabilities:
            # Extract description from vulnerability
            description = self._extract_description(vuln)
            if description:
                severity = self.predict_single(description)
                results.append(severity)
            else:
                # If no description available, default to Medium
                results.append('Medium')
                
        return results
    
    def _extract_description(self, vulnerability):
        """
        Extract description text from a vulnerability dictionary.
        
        Args:
            vulnerability (dict): Vulnerability data
            
        Returns:
            str: Description text or empty string if not found
        """
        # Try different possible fields where description might be stored
        if 'description' in vulnerability:
            return vulnerability['description']
        elif 'cve' in vulnerability and 'description' in vulnerability['cve']:
            return vulnerability['cve']['description']
        elif 'summary' in vulnerability:
            return vulnerability['summary']
        elif 'details' in vulnerability:
            return vulnerability['details']
        
        # Handle nested structures that might contain description
        for key, value in vulnerability.items():
            if isinstance(value, dict) and 'description' in value:
                return value['description']
            elif isinstance(value, str) and len(value) > 20:  # Long text field might be description
                return value
                
        return ""
