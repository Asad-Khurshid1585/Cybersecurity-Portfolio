"""
Flask application for the vulnerability remediation system.
"""

from flask import Flask, request, jsonify, render_template, send_from_directory
from flask_cors import CORS
import logging
import os
import json
import requests
from datetime import datetime

# Import project modules
from data_collection.nvd_collector import NVDCollector
from data_collection.scanner_interface import NmapScanner
from models.severity_classifier import VulnerabilitySeverityClassifier
from models.remediation_generator import RemediationGenerator

logger = logging.getLogger(__name__)

def create_app():
    """Create and configure the Flask application."""
    app = Flask(__name__, static_folder='../frontend/static', template_folder='../frontend/templates')
    CORS(app)
    
    # Load configuration
    app.config.from_mapping(
        SECRET_KEY=os.environ.get('SECRET_KEY', 'dev'),
        NVD_API_KEY=os.environ.get('NVD_API_KEY'),
        DATA_DIR=os.path.join(app.root_path, '..', 'data')
    )
    
    # Initialize components
    nvd_collector = NVDCollector(api_key=app.config.get('NVD_API_KEY'))
    scanner = NmapScanner(output_dir=os.path.join(app.config.get('DATA_DIR'), 'scans'))
    severity_classifier = VulnerabilitySeverityClassifier()
    remediation_generator = RemediationGenerator()
    
    # Ensure data directory exists
    os.makedirs(app.config.get('DATA_DIR'), exist_ok=True)
    
    # Routes
    @app.route('/')
    def index():
        """Render the main dashboard."""
        return render_template('index.html')
    
    @app.route('/api/scan', methods=['POST'])
    def start_scan():
        """
        Start a new vulnerability scan.
        
        Request JSON:
        {
            "targets": ["192.168.1.1", "example.com"],
            "scan_type": "basic"  // options: basic, full, vuln, os
        }
        """
        data = request.get_json()
        
        if not data or 'targets' not in data:
            return jsonify({'error': 'No targets specified'}), 400
        
        targets = data['targets']
        scan_type = data.get('scan_type', 'basic')
        
        try:
            # Start scan
            scan_results = scanner.scan(targets, scan_type=scan_type)
            
            if not scan_results:
                return jsonify({'error': 'Scan failed'}), 500
            
            # Extract vulnerabilities
            vulnerabilities = scanner.get_vulnerability_report(scan_results)
            
            # Classify severity
            if vulnerabilities:
                severities = severity_classifier.predict(vulnerabilities)
                
                # Add severity to vulnerabilities
                for vuln, severity in zip(vulnerabilities, severities):
                    vuln['severity'] = severity
            
            # Save scan results
            scan_id = f"scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            results_file = os.path.join(app.config.get('DATA_DIR'), f"{scan_id}.json")
            
            with open(results_file, 'w') as f:
                json.dump({
                    'scan_id': scan_id,
                    'timestamp': datetime.now().isoformat(),
                    'targets': targets,
                    'scan_type': scan_type,
                    'results': scan_results,
                    'vulnerabilities': vulnerabilities
                }, f)
            
            return jsonify({
                'scan_id': scan_id,
                'vulnerabilities_count': len(vulnerabilities),
                'status': 'completed',
                'results_file': results_file
            })
            
        except Exception as e:
            logger.error(f"Scan error: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/api/vulnerabilities', methods=['GET'])
    def get_vulnerabilities():
        """
        Get all vulnerabilities from a specific scan or from all scans.
        
        Query parameters:
        - scan_id: (optional) ID of the specific scan
        - severity: (optional) Filter by severity (Low, Medium, High, Critical)
        """
        scan_id = request.args.get('scan_id')
        severity = request.args.get('severity')
        
        try:
            all_vulnerabilities = []
            
            if scan_id:
                # Get vulnerabilities from specific scan
                results_file = os.path.join(app.config.get('DATA_DIR'), f"{scan_id}.json")
                if not os.path.exists(results_file):
                    return jsonify({'error': 'Scan not found'}), 404
                
                with open(results_file, 'r') as f:
                    scan_data = json.load(f)
                    vulnerabilities = scan_data.get('vulnerabilities', [])
            else:
                # Get vulnerabilities from all scans
                data_dir = app.config.get('DATA_DIR')
                for filename in os.listdir(data_dir):
                    if filename.startswith('scan_') and filename.endswith('.json'):
                        file_path = os.path.join(data_dir, filename)
                        with open(file_path, 'r') as f:
                            scan_data = json.load(f)
                            vulnerabilities = scan_data.get('vulnerabilities', [])
                            
                            # Add scan_id to each vulnerability
                            for vuln in vulnerabilities:
                                vuln['scan_id'] = scan_data.get('scan_id')
                            
                            all_vulnerabilities.extend(vulnerabilities)
                
                vulnerabilities = all_vulnerabilities
            
            # Filter by severity if specified
            if severity:
                vulnerabilities = [v for v in vulnerabilities if v.get('severity') == severity]
            
            return jsonify({
                'count': len(vulnerabilities),
                'vulnerabilities': vulnerabilities
            })
            
        except Exception as e:
            logger.error(f"Error getting vulnerabilities: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/api/remediation/<vulnerability_id>', methods=['GET'])
    def get_remediation(vulnerability_id):
        """
        Get remediation suggestions for a specific vulnerability.
        
        Path parameters:
        - vulnerability_id: ID of the vulnerability
        """
        try:
            if not vulnerability_id:
                logger.error("No vulnerability ID provided")
                return jsonify({
                    'error': 'Missing vulnerability ID',
                    'remediation': remediation_generator._get_generic_remediation()  # Provide generic remediation anyway
                }), 400
            
            # Find the vulnerability
            vulnerability = None
            data_dir = app.config.get('DATA_DIR')
            
            for filename in os.listdir(data_dir):
                if filename.startswith('scan_') and filename.endswith('.json'):
                    file_path = os.path.join(data_dir, filename)
                    try:
                        with open(file_path, 'r') as f:
                            scan_data = json.load(f)
                            vulnerabilities = scan_data.get('vulnerabilities', [])
                            
                            for vuln in vulnerabilities:
                                if vuln.get('cve_id') == vulnerability_id or str(vuln.get('id')) == vulnerability_id:
                                    vulnerability = vuln
                                    break
                    except json.JSONDecodeError:
                        logger.error(f"Invalid JSON in file: {file_path}")
                        continue
                    
                    if vulnerability:
                        break
            
            if not vulnerability:
                logger.warning(f"Vulnerability not found: {vulnerability_id}")
                return jsonify({
                    'warning': 'Vulnerability not found',
                    'vulnerability_id': vulnerability_id,
                    'remediation': remediation_generator._get_generic_remediation()  # Return generic instead of 404
                })
            
            # Generate remediation suggestion
            remediation = remediation_generator.get_remediation_suggestion(vulnerability)
            
            # Ensure remediation has all required fields for frontend
            required_fields = ['id', 'title', 'description', 'remediation_steps']
            for field in required_fields:
                if field not in remediation:
                    if field == 'id':
                        remediation[field] = 'REM-GENERIC'
                    elif field == 'title':
                        remediation[field] = 'Review and Address Vulnerability'
                    elif field == 'description':
                        remediation[field] = 'This vulnerability requires further investigation.'
                    elif field == 'remediation_steps':
                        remediation[field] = ['Research this vulnerability', 'Apply appropriate updates']
            
            return jsonify({
                'vulnerability_id': vulnerability_id,
                'remediation': remediation
            })
            
        except Exception as e:
            logger.error(f"Error generating remediation: {e}", exc_info=True)
            return jsonify({
                'error': str(e),
                'vulnerability_id': vulnerability_id,
                'remediation': remediation_generator._get_generic_remediation()  # Return generic on error
            })
    
    @app.route('/api/statistics', methods=['GET'])
    def get_statistics():
        """Get statistics about vulnerabilities."""
        try:
            all_vulnerabilities = []
            data_dir = app.config.get('DATA_DIR')
            
            for filename in os.listdir(data_dir):
                if filename.startswith('scan_') and filename.endswith('.json'):
                    file_path = os.path.join(data_dir, filename)
                    with open(file_path, 'r') as f:
                        scan_data = json.load(f)
                        vulnerabilities = scan_data.get('vulnerabilities', [])
                        all_vulnerabilities.extend(vulnerabilities)
            
            # Count by severity
            severity_counts = {
                'Critical': 0,
                'High': 0,
                'Medium': 0,
                'Low': 0,
                'Unknown': 0
            }
            
            for vuln in all_vulnerabilities:
                severity = vuln.get('severity', 'Unknown')
                severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
            # Count by host
            host_counts = {}
            for vuln in all_vulnerabilities:
                host = vuln.get('host', 'Unknown')
                host_counts[host] = host_counts.get(host, 0) + 1
            
            return jsonify({
                'total_vulnerabilities': len(all_vulnerabilities),
                'severity_distribution': severity_counts,
                'host_distribution': host_counts,
                'recent_scans': len([f for f in os.listdir(data_dir) if f.startswith('scan_') and f.endswith('.json')])
            })
            
        except Exception as e:
            logger.error(f"Error getting statistics: {e}")
            return jsonify({'error': str(e)}), 500

    @app.route('/api/nvd/search', methods=['GET'])
    def search_nvd():
        """
        Search NVD database for vulnerabilities.
        
        Query parameters:
        - keywords: Search keywords
        - max_results: Maximum number of results to return
        """
        keywords = request.args.get('keywords', '')
        max_results = int(request.args.get('max_results', 10))
        
        try:
            # Use NVD collector to fetch CVEs
            cves = nvd_collector.fetch_cves(max_results=max_results)
            
            if not keywords:
                return jsonify({
                    'count': len(cves),
                    'vulnerabilities': cves[:max_results]
                })
            
            # Filter by keywords
            filtered_cves = []
            for cve in cves:
                cve_data = cve.get('cve', {})
                description = cve_data.get('descriptions', [{}])[0].get('value', '').lower()
                
                if keywords.lower() in description:
                    filtered_cves.append(cve)
                    if len(filtered_cves) >= max_results:
                        break
            
            return jsonify({
                'count': len(filtered_cves),
                'vulnerabilities': filtered_cves
            })
            
        except Exception as e:
            logger.error(f"Error searching NVD: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/api/chat', methods=['POST'])
    def chat():
        """
        Chat with the local LLM.
        
        Request JSON:
        {
            "message": "User's message here"
        }
        """
        try:
            data = request.get_json()
            
            if not data or 'message' not in data:
                return jsonify({'error': 'No message provided'}), 400
            
            user_message = data['message']
            
            # System message for the AI to act as a vulnerability management assistant
            system_message = """You are an AI assistant specialized in vulnerability management and cybersecurity. 
            Provide concise, accurate, and helpful responses to questions about vulnerabilities, 
            security best practices, and remediation strategies. When appropriate, include code examples 
            or commands that might help with security tasks."""
            
            # Prepare the request to the local LLM
            llm_payload = {
                "model": "qwen3-1.7b",  # Use the model name specified in your curl example
                "messages": [
                    {"role": "system", "content": system_message},
                    {"role": "user", "content": user_message}
                ],
                "temperature": 0.7,
                "max_tokens": -1,
                "stream": False
            }
            
            # Send request to the local LLM server
            response = requests.post(
                "http://localhost:1234/v1/chat/completions",
                headers={"Content-Type": "application/json"},
                json=llm_payload,
                timeout=30
            )
            
            # Check if the request was successful
            if response.status_code == 200:
                llm_response = response.json()
                ai_message = llm_response.get('choices', [{}])[0].get('message', {}).get('content', '')
                
                if not ai_message:
                    return jsonify({
                        'error': 'Empty response from LLM',
                        'response': 'I apologize, but I couldn\'t generate a response at this time. Please try again.'
                    })
                
                return jsonify({'response': ai_message})
            else:
                logger.error(f"LLM API error: {response.status_code} - {response.text}")
                return jsonify({
                    'error': f'LLM API returned status code {response.status_code}',
                    'response': 'Sorry, I encountered an error while processing your request. Please try again later.'
                })
                
        except requests.exceptions.ConnectionError:
            logger.error("Failed to connect to the local LLM server")
            return jsonify({
                'error': 'Could not connect to LLM server',
                'response': 'The AI service is currently unavailable. Please ensure the local LLM server is running and try again.'
            })
        except Exception as e:
            logger.error(f"Chat error: {str(e)}", exc_info=True)
            return jsonify({
                'error': str(e),
                'response': 'I encountered an unexpected error. Please try again later.'
            })

    # Add static files route for the frontend
    @app.route('/static/<path:filename>')
    def serve_static(filename):
        return send_from_directory(app.static_folder, filename)

    return app