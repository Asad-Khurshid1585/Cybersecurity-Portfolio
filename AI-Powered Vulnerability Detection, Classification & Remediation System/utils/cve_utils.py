"""
Utility functions for working with CVEs and CVSS scores.
"""

import logging
import re
import requests
from datetime import datetime

logger = logging.getLogger(__name__)

def parse_cvss_vector(vector_string):
    """
    Parse a CVSS vector string into a dictionary of metrics.
    
    Args:
        vector_string: CVSS vector string (e.g., 'AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H')
        
    Returns:
        Dictionary of CVSS metrics
    """
    if not vector_string:
        return {}
    
    metrics = {}
    
    # Determine CVSS version
    if vector_string.startswith('CVSS:3'):
        metrics['cvss_version'] = 3.0
        # Remove the version prefix
        vector_string = vector_string.split('/', 1)[1] if '/' in vector_string else vector_string
    else:
        metrics['cvss_version'] = 2.0
    
    # Parse metrics
    try:
        for metric in vector_string.split('/'):
            if not metric or ':' not in metric:
                continue
                
            key, value = metric.split(':', 1)
            metrics[key] = value
    except Exception as e:
        logger.error(f"Error parsing CVSS vector: {e}")
    
    # Map CVSS v3 metrics to more readable names
    mapping = {
        'AV': 'attack_vector',
        'AC': 'attack_complexity',
        'PR': 'privileges_required',
        'UI': 'user_interaction',
        'S': 'scope',
        'C': 'confidentiality_impact',
        'I': 'integrity_impact',
        'A': 'availability_impact'
    }
    
    for short_key, long_key in mapping.items():
        if short_key in metrics:
            metrics[long_key] = metrics.pop(short_key)
    
    return metrics

def calculate_cvss_score(metrics):
    """
    Calculate CVSS base score from metrics.
    
    Args:
        metrics: Dictionary of CVSS metrics
        
    Returns:
        CVSS base score
    """
    # This is a simplified calculation - for production use,
    # consider a more complete implementation or library
    
    if not metrics:
        return 0.0
    
    # Check if we already have a base score
    if isinstance(metrics.get('base_score'), (int, float)):
        return float(metrics['base_score'])
    
    # Very simple estimation based on impact metrics
    score = 0.0
    
    # Attack vector contribution
    av = metrics.get('attack_vector', '').upper()
    if av == 'N' or av == 'NETWORK':
        score += 0.85
    elif av == 'A' or av == 'ADJACENT_NETWORK':
        score += 0.62
    elif av == 'L' or av == 'LOCAL':
        score += 0.55
    elif av == 'P' or av == 'PHYSICAL':
        score += 0.2
    
    # Impact metrics contribution
    for impact in ['confidentiality_impact', 'integrity_impact', 'availability_impact']:
        impact_value = metrics.get(impact, '').upper()
        if impact_value == 'H' or impact_value == 'HIGH':
            score += 0.56
        elif impact_value == 'L' or impact_value == 'LOW':
            score += 0.22
    
    # Round to 1 decimal place and cap at 10.0
    return min(round(score * 1.5, 1), 10.0)

def get_cve_details(cve_id):
    """
    Get details for a CVE from the NVD API.
    
    Args:
        cve_id: CVE ID (e.g., 'CVE-2021-44228')
        
    Returns:
        Dictionary with CVE details or None if not found
    """
    if not cve_id or not re.match(r'^CVE-\d{4}-\d{4,}$', cve_id):
        logger.warning(f"Invalid CVE ID format: {cve_id}")
        return None
    
    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
    
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        
        data = response.json()
        vulnerabilities = data.get('vulnerabilities', [])
        
        if not vulnerabilities:
            logger.warning(f"CVE not found: {cve_id}")
            return None
        
        return vulnerabilities[0]
    
    except Exception as e:
        logger.error(f"Error fetching CVE details: {e}")
        return None

def get_cve_references(cve_id):
    """
    Get references for a CVE from the NVD API.
    
    Args:
        cve_id: CVE ID (e.g., 'CVE-2021-44228')
        
    Returns:
        List of references or empty list if not found
    """
    cve_details = get_cve_details(cve_id)
    
    if not cve_details:
        return []
    
    try:
        references = cve_details.get('cve', {}).get('references', [])
        return references
    except Exception as e:
        logger.error(f"Error extracting CVE references: {e}")
        return []

def severity_to_risk_score(severity):
    """
    Convert a severity string to a numeric risk score.
    
    Args:
        severity: Severity string ('Critical', 'High', 'Medium', 'Low')
        
    Returns:
        Risk score (1-10)
    """
    severity_map = {
        'Critical': 10.0,
        'High': 8.0,
        'Medium': 5.0,
        'Low': 2.0
    }
    
    return severity_map.get(severity, 0.0)

def age_factor(published_date):
    """
    Calculate a risk factor based on the vulnerability's age.
    
    Args:
        published_date: Date the vulnerability was published
        
    Returns:
        Age factor (0.5-1.5)
    """
    if not published_date:
        return 1.0
    
    try:
        if isinstance(published_date, str):
            published_date = datetime.fromisoformat(published_date.replace('Z', '+00:00'))
        
        # Calculate days since publication
        days = (datetime.now().astimezone() - published_date.astimezone()).days
        
        # New vulnerabilities (less than 30 days) get higher priority
        if days < 30:
            return min(1.5, 1 + (30 - days) / 30)
        # Very old vulnerabilities (more than a year) get lower priority
        elif days > 365:
            return 0.5
        else:
            return 1.0
    
    except Exception as e:
        logger.error(f"Error calculating age factor: {e}")
        return 1.0

if __name__ == "__main__":
    # Example usage
    vector = "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H"
    metrics = parse_cvss_vector(vector)
    print(f"Parsed metrics: {metrics}")
    
    score = calculate_cvss_score(metrics)
    print(f"Calculated score: {score}")
